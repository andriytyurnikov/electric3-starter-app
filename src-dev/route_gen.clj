(ns route-gen
  "Discovers page.cljc files under src/electric_starter_app/routes/ and
   generates a routes-table namespace with all requires and a case-based
   dispatch e/defn. Designed to run as a shadow-cljs :compile-prepare hook."
  (:require [clojure.java.io :as io]
            [clojure.string :as str]))

(def routes-dir "src/electric_starter_app/routes")
(def output-file "src-generated/electric_starter_app/routes_table.cljc")
(def ^:private last-routes (atom nil))

(defn discover-routes
  "Walks routes-dir, finds page.cljc files, returns a seq of maps:
     {:path \"/\"     :ns-sym electric-starter-app.routes.home.page  :alias route-home}
     {:path \"/about\" :ns-sym electric-starter-app.routes.about.page :alias route-about}
   Convention: routes/home/page.cljc maps to \"/\". All other dirs map to their path."
  []
  (let [base (io/file routes-dir)]
    (when (.isDirectory base)
      (->> (file-seq base)
           (filter #(= (.getName %) "page.cljc"))
           (filter (fn [f]
                     (let [rel (.relativize (.toPath base) (.toPath (.getParentFile f)))]
                       (pos? (.getNameCount rel)))))
           (map (fn [f]
                  (let [rel      (.relativize (.toPath base) (.toPath (.getParentFile f)))
                        dir-segs (mapv str rel)
                        segments (mapv #(str/replace % "_" "-") dir-segs)
                        url-path (if (= segments ["home"])
                                   "/"
                                   (str "/" (str/join "/" segments)))
                        ns-parts (concat ["electric-starter-app" "routes"]
                                         segments
                                         ["page"])
                        ns-sym   (symbol (str/join "." ns-parts))
                        alias    (symbol (str "route-" (str/join "-" segments)))]
                    {:path     url-path
                     :ns-sym   ns-sym
                     :alias    alias})))
           (sort-by :path)))))

(defn generate-routes-table!
  "Writes routes_table.cljc based on discovered routes.
   Skips writing when routes haven't changed to avoid triggering
   shadow-cljs recompile loops."
  []
  (let [routes (discover-routes)]
    (when (seq routes)
      (if (= routes @last-routes)
        (println "[route-gen] Routes unchanged, skipping write.")
        (let [requires (str/join "\n            "
                                 (map (fn [{:keys [ns-sym alias]}]
                                        (str "[" ns-sym " :as " alias "]"))
                                      routes))
              cases    (str/join "\n      "
                                 (map (fn [{:keys [path alias]}]
                                        (str "\"" path "\" (" alias "/Page)"))
                                      routes))
              content  (str ";; GENERATED FILE — do not edit. Regenerated by route-gen on every compile.\n"
                            "(ns electric-starter-app.routes-table\n"
                            "  (:require [hyperfiddle.electric3 :as e]\n"
                            "            [hyperfiddle.electric-dom3 :as dom]\n"
                            "            " requires "))\n"
                            "\n"
                            "(e/defn Route [path]\n"
                            "  (case path\n"
                            "    " cases "\n"
                            "    (e/client (dom/h1 (dom/text \"404 — Not Found\")))))\n")]
          (reset! last-routes routes)
          (spit output-file content)
          (println "[route-gen] Wrote" output-file "with" (count routes) "route(s):")
          (doseq [{:keys [path ns-sym]} routes]
            (println "  " path "→" ns-sym)))))))

(defn shadow-cljs-hook
  "shadow-cljs build hook — runs before compilation to regenerate the routes table.
   Register in shadow-cljs.edn as: (route-gen/shadow-cljs-hook)"
  {:shadow.build/stage :compile-prepare}
  [build-state & _args]
  (generate-routes-table!)
  build-state)
